#!/usr/bin/env python3
# chat_sanduicheira_full.py
import re
import sys

class State:
    SAUDACAO = "SAUDACAO"
    TIPO_PEDIDO = "TIPO_PEDIDO"
    MENU_PRINCIPAL = "MENU_PRINCIPAL"
    ESCOLHER_MENU = "ESCOLHER_MENU"
    ESCOLHER_ITEM = "ESCOLHER_ITEM"
    QUANTIDADE = "QUANTIDADE"
    ADICIONAR_MAIS = "ADICIONAR_MAIS"
    RESUMO = "RESUMO"
    ALTERAR_PEDIDO = "ALTERAR_PEDIDO"
    ALTERAR_SELECAO = "ALTERAR_SELECAO"
    ENDERECO = "ENDERECO"
    PAGAMENTO = "PAGAMENTO"
    CARTAO = "CARTAO"
    FINALIZAR = "FINALIZAR"

class SanduicheiraAssistant:
    def __init__(self):
        self.current_state = State.SAUDACAO
        # Card√°pio separado por categorias
        self.cardapio = {
            "comidas": {
                1: ("Misto Quente", 8.00),
                2: ("X-Burger", 12.00),
                3: ("X-Salada", 15.00),
                4: ("X-Bacon", 18.00),
                5: ("X-Tudo", 22.00),
                6: ("Hamb√∫rguer Artesanal", 28.00),
                7: ("Cachorro-Quente", 10.00),
                8: ("Pizza Brotinho", 15.00),
            },
            "bebidas": {
                1: ("Refrigerante Lata", 6.00),
                2: ("Suco Natural", 8.00),
                3: ("√Ågua Mineral", 4.00),
                4: ("Milk-shake", 12.00),
                5: ("Cerveja Latinha", 7.00),
            },
            "sobremesas": {
                1: ("Pudim", 7.00),
                2: ("A√ßa√≠", 10.00),
                3: ("Brownie", 9.00),
                4: ("Sorvete", 6.00),
                5: ("Cheesecake", 12.00),
            }
        }
        self._reset_session()

    # ---------------- util ----------------
    def normalize(self, s: str) -> str:
        if not s:
            return ""
        s = s.lower()
        replacements = {"√°":"a","√£":"a","√¢":"a","√†":"a","√©":"e","√™":"e","√≠":"i","√≥":"o","√µ":"o","√¥":"o","√∫":"u","√ß":"c"}
        for k,v in replacements.items():
            s = s.replace(k,v)
        s = re.sub(r"[^\w\s]", " ", s)
        s = re.sub(r"\s+", " ", s).strip()
        return s

    def read_int(self, user_input: str):
        try:
            return int(user_input.strip())
        except:
            return None

    def mostrar_menu_categoria(self, categoria: str):
        menu = self.cardapio[categoria]
        out = [f"--- {categoria.capitalize()} ---"]
        for cod, (nome, preco) in menu.items():
            out.append(f"{cod}) {nome} - R$ {preco:.2f}")
        out.append("0) Voltar ao menu principal")
        out.append("Escolha o n√∫mero do item:")
        return "\n".join(out)

    def mostrar_menu_principal(self):
        return (
            "Escolha a categoria:\n"
            "1) Comidas\n"
            "2) Bebidas\n"
            "3) Sobremesas\n"
            "4) Ver resumo do pedido\n"
            "0) Finalizar / Ir para resumo\n"
            "Digite o n√∫mero da op√ß√£o:"
        )

    def resumo_pedido_texto(self):
        if not self.pedido:
            return "Seu pedido est√° vazio."
        lines = ["Resumo do pedido:"]
        total = 0.0
        for idx, it in enumerate(self.pedido, start=1):
            subtotal = it["preco"] * it["quantidade"]
            total += subtotal
            lines.append(f"{idx}) {it['nome']} - Qtd: {it['quantidade']} - R$ {it['preco']:.2f} - Subtotal: R$ {subtotal:.2f}")
        lines.append(f"\nTotal geral: R$ {total:.2f}")
        return "\n".join(lines)

    def calcular_total(self):
        return sum(it["preco"] * it["quantidade"] for it in self.pedido)

    # ---------------- handlers ----------------
    def handle_saudacao(self, _):
        self.current_state = State.TIPO_PEDIDO
        return (
            "Bem-vindo √† Sanduicheira! ü•™\n"
            "Como deseja consumir?\n"
            "1) Comer no restaurante\n"
            "2) Entrega em domic√≠lio\n"
            "Digite o n√∫mero da op√ß√£o:"
        )

    def handle_tipo_pedido(self, user_input):
        op = self.read_int(user_input)
        if op == 1:
            self.tipo = "local"
            self.current_state = State.MENU_PRINCIPAL
            return "Voc√™ escolheu: Comer no restaurante.\n\n" + self.mostrar_menu_principal()
        elif op == 2:
            self.tipo = "entrega"
            self.current_state = State.MENU_PRINCIPAL
            return "Voc√™ escolheu: Entrega em domic√≠lio.\n\n" + self.mostrar_menu_principal()
        else:
            return "Op√ß√£o inv√°lida. Digite 1 para local ou 2 para entrega."

    def handle_menu_principal(self, user_input):
        op = self.read_int(user_input)
        if op == 1:
            self.current_category = "comidas"
            self.current_state = State.ESCOLHER_MENU
            return self.mostrar_menu_categoria("comidas")
        elif op == 2:
            self.current_category = "bebidas"
            self.current_state = State.ESCOLHER_MENU
            return self.mostrar_menu_categoria("bebidas")
        elif op == 3:
            self.current_category = "sobremesas"
            self.current_state = State.ESCOLHER_MENU
            return self.mostrar_menu_categoria("sobremesas")
        elif op == 4:
            self.current_state = State.RESUMO
            return self.resumo_pedido_texto() + "\n\n1) Ir para op√ß√µes de altera√ß√£o / 2) Ir para pagamento"
        elif op == 0:
            self.current_state = State.RESUMO
            return self.resumo_pedido_texto() + "\n\n1) Ir para op√ß√µes de altera√ß√£o / 2) Ir para pagamento"
        else:
            return "Op√ß√£o inv√°lida. Digite um n√∫mero do menu."

    def handle_escolher_menu(self, user_input):
        op = self.read_int(user_input)
        if op is None:
            return "Digite apenas o n√∫mero do item (ou 0 para voltar)."
        if op == 0:
            self.current_state = State.MENU_PRINCIPAL
            return self.mostrar_menu_principal()
        menu = self.cardapio[self.current_category]
        if op in menu:
            nome, preco = menu[op]
            self.item_em_selecao = {"nome": nome, "preco": preco, "categoria": self.current_category}
            self.current_state = State.QUANTIDADE
            return f"Quantos '{nome}' voc√™ deseja? (Digite o n√∫mero da quantidade)"
        else:
            return "Op√ß√£o inv√°lida nessa categoria. Escolha um n√∫mero existente ou 0 para voltar."

    def handle_quantidade(self, user_input):
        qtd = self.read_int(user_input)
        if qtd is None or qtd <= 0:
            return "Quantidade inv√°lida. Digite apenas um n√∫mero inteiro maior que zero."
        # adiciona item ao pedido (empilha para permitir m√∫ltiplos mesmos itens separadamente)
        entry = {
            "nome": self.item_em_selecao["nome"],
            "preco": self.item_em_selecao["preco"],
            "categoria": self.item_em_selecao["categoria"],
            "quantidade": qtd
        }
        self.pedido.append(entry)
        self.current_state = State.ADICIONAR_MAIS
        return (
            f"Item '{entry['nome']}' x{qtd} adicionado ao pedido.\n\n"
            "Deseja adicionar mais itens?\n"
            "1) Sim - voltar ao menu principal\n"
            "2) N√£o - ver resumo/ir para pagamento\n"
            "Digite a op√ß√£o:"
        )

    def handle_adicionar_mais(self, user_input):
        op = self.read_int(user_input)
        if op == 1:
            self.current_state = State.MENU_PRINCIPAL
            return self.mostrar_menu_principal()
        elif op == 2:
            self.current_state = State.RESUMO
            return self.resumo_pedido_texto() + "\n\n1) Alterar pedido\n2) Prosseguir para pagamento"
        else:
            return "Op√ß√£o inv√°lida. Digite 1 para Sim ou 2 para N√£o."

    def handle_resumo(self, user_input):
        op = self.read_int(user_input)
        if op == 1:
            # abrir menu de altera√ß√£o
            if not self.pedido:
                self.current_state = State.MENU_PRINCIPAL
                return "Pedido vazio. Voltando ao menu principal.\n\n" + self.mostrar_menu_principal()
            self.current_state = State.ALTERAR_PEDIDO
            return (
                "Op√ß√µes de altera√ß√£o:\n"
                "1) Remover um item\n"
                "2) Alterar quantidade de um item\n"
                "3) Adicionar mais itens\n"
                "4) Limpar pedido (apagar tudo)\n"
                "0) Voltar ao resumo\n"
                "Digite a op√ß√£o:"
            )
        elif op == 2:
            # se for entrega, pedir endere√ßo antes de pagamento
            if self.tipo == "entrega":
                self.current_state = State.ENDERECO
                return "Digite o endere√ßo completo para entrega (rua, n√∫mero, complemento, bairro, cidade):"
            else:
                self.current_state = State.PAGAMENTO
                return self.mostrar_metodos_pagamento()
        else:
            return "Op√ß√£o inv√°lida no resumo. Digite 1 ou 2."

    def handle_alterar_pedido(self, user_input):
        op = self.read_int(user_input)
        if op == 1:
            # remover item
            self.current_state = State.ALTERAR_SELECAO
            self.alteracao_tipo = "remover"
            return self._listar_itens_para_alteracao("Escolha o n√∫mero do item que deseja remover (ou 0 para cancelar):")
        elif op == 2:
            self.current_state = State.ALTERAR_SELECAO
            self.alteracao_tipo = "alterar_qtd"
            return self._listar_itens_para_alteracao("Escolha o n√∫mero do item que deseja alterar a quantidade (ou 0 para cancelar):")
        elif op == 3:
            self.current_state = State.MENU_PRINCIPAL
            return "Voltando ao menu principal para adicionar mais itens.\n\n" + self.mostrar_menu_principal()
        elif op == 4:
            self.pedido = []
            self.current_state = State.MENU_PRINCIPAL
            return "Pedido limpo. Voltando ao menu principal.\n\n" + self.mostrar_menu_principal()
        elif op == 0:
            self.current_state = State.RESUMO
            return self.resumo_pedido_texto() + "\n\n1) Alterar pedido\n2) Prosseguir para pagamento"
        else:
            return "Op√ß√£o inv√°lida. Escolha uma das op√ß√µes do menu de altera√ß√£o."

    def _listar_itens_para_alteracao(self, prompt):
        if not self.pedido:
            self.current_state = State.MENU_PRINCIPAL
            return "Pedido vazio. Voltando ao menu principal.\n\n" + self.mostrar_menu_principal()
        lines = ["Itens do pedido:"]
        for idx, it in enumerate(self.pedido, start=1):
            lines.append(f"{idx}) {it['nome']} - Qtd: {it['quantidade']} - R$ {it['preco']:.2f}")
        lines.append("0) Cancelar e voltar")
        lines.append(prompt)
        return "\n".join(lines)

    def handle_alterar_selecao(self, user_input):
        sel = self.read_int(user_input)
        if sel is None:
            return "Digite apenas o n√∫mero do item (ou 0 para cancelar)."
        if sel == 0:
            self.current_state = State.ALTERAR_PEDIDO
            return (
                "Voltando ao menu de altera√ß√£o:\n"
                "1) Remover um item\n"
                "2) Alterar quantidade de um item\n"
                "3) Adicionar mais itens\n"
                "4) Limpar pedido\n"
                "0) Voltar ao resumo\n"
            )
        if sel < 1 or sel > len(self.pedido):
            return "N√∫mero de item inv√°lido. Tente novamente."
        # tem sele√ß√£o v√°lida
        if self.alteracao_tipo == "remover":
            removed = self.pedido.pop(sel - 1)
            self.current_state = State.RESUMO
            return f"Item '{removed['nome']}' removido.\n\n" + self.resumo_pedido_texto() + "\n\n1) Alterar pedido\n2) Prosseguir para pagamento"
        elif self.alteracao_tipo == "alterar_qtd":
            self.selecao_para_alterar = sel - 1
            self.current_state = State.ALTERAR_SELECAO  # manter no mesmo estado at√© receber quantidade
            self.alteracao_tipo = "confirmar_qtd"
            return "Digite a nova quantidade para o item selecionado:"
        elif self.alteracao_tipo == "confirmar_qtd":
            # shouldn't happen here
            return "Erro de estado. Voltando ao resumo." 

    def handle_alterar_confirmar_qtd(self, user_input):
        # espera a nova quantidade para o item previamente escolhido
        qtd = self.read_int(user_input)
        if qtd is None or qtd <= 0:
            return "Quantidade inv√°lida. Digite um n√∫mero inteiro maior que zero."
        idx = getattr(self, "selecao_para_alterar", None)
        if idx is None or idx < 0 or idx >= len(self.pedido):
            self.current_state = State.RESUMO
            return "Erro: sele√ß√£o inv√°lida. Voltando ao resumo.\n\n" + self.resumo_pedido_texto()
        self.pedido[idx]["quantidade"] = qtd
        nome = self.pedido[idx]["nome"]
        self.current_state = State.RESUMO
        return f"Quantidade do item '{nome}' atualizada para {qtd}.\n\n" + self.resumo_pedido_texto() + "\n\n1) Alterar pedido\n2) Prosseguir para pagamento"

    def handle_endereco(self, user_input):
        text = user_input.strip()
        if len(text) < 5:
            return "Endere√ßo muito curto. Por favor digite o endere√ßo completo (rua, n√∫mero, bairro, cidade)."
        self.endereco = text
        self.current_state = State.PAGAMENTO
        return "Endere√ßo registrado!\n\n" + self.mostrar_metodos_pagamento()

    def mostrar_metodos_pagamento(self):
        return (
            "Escolha o m√©todo de pagamento:\n"
            "1) PIX\n"
            "2) Dinheiro\n"
            "3) Cart√£o\n"
            "Digite o n√∫mero da op√ß√£o:"
        )

    def handle_pagamento(self, user_input):
        op = self.read_int(user_input)
        if op == 1:
            self.metodo_pagamento = "PIX"
            return self.finalizar_pedido()
        elif op == 2:
            self.metodo_pagamento = "Dinheiro"
            return self.finalizar_pedido()
        elif op == 3:
            self.current_state = State.CARTAO
            return "Cart√£o selecionado. Escolha:\n1) Cr√©dito\n2) D√©bito\nDigite o n√∫mero:"
        else:
            return "Op√ß√£o inv√°lida de pagamento. Digite 1, 2 ou 3."

    def handle_cartao(self, user_input):
        op = self.read_int(user_input)
        if op == 1:
            self.metodo_pagamento = "Cart√£o de Cr√©dito"
            return self.finalizar_pedido()
        elif op == 2:
            self.metodo_pagamento = "Cart√£o de D√©bito"
            return self.finalizar_pedido()
        else:
            return "Op√ß√£o inv√°lida. Digite 1 para Cr√©dito ou 2 para D√©bito."

    def finalizar_pedido(self):
        total = self.calcular_total()
        lines = [self.resumo_pedido_texto(),
                 f"\nPagamento: {self.metodo_pagamento}",
                 f"Total a pagar: R$ {total:.2f}"]
        if self.tipo == "entrega":
            lines.append(f"Endere√ßo de entrega: {self.endereco}")
        lines.append("\nPedido finalizado! ‚úÖ\nObrigado por comprar na Sanduicheira! ü•™")
        mensagem = "\n".join(lines)
        self._reset_session()
        self.current_state = State.SAUDACAO
        return mensagem

    # ---------------- dispatch/responder ----------------
    def respond(self, user_input: str):
        raw = user_input or ""
        # Encadeamento de estados que precisam de distin√ß√£o especial
        if self.current_state == State.SAUDACAO:
            return self.handle_saudacao(raw)
        if self.current_state == State.TIPO_PEDIDO:
            return self.handle_tipo_pedido(raw)
        if self.current_state == State.MENU_PRINCIPAL:
            return self.handle_menu_principal(raw)
        if self.current_state == State.ESCOLHER_MENU:
            return self.handle_escolher_menu(raw)
        if self.current_state == State.QUANTIDADE:
            return self.handle_quantidade(raw)
        if self.current_state == State.ADICIONAR_MAIS:
            return self.handle_adicionar_mais(raw)
        if self.current_state == State.RESUMO:
            return self.handle_resumo(raw)
        if self.current_state == State.ALTERAR_PEDIDO:
            return self.handle_alterar_pedido(raw)
        if self.current_state == State.ALTERAR_SELECAO:
            # two-step: either selecting which item or confirming new qty
            if getattr(self, "alteracao_tipo", "") == "confirmar_qtd":
                # received new quantity
                return self.handle_alterar_confirmar_qtd(raw)
            else:
                return self.handle_alterar_selecao(raw)
        if self.current_state == State.ENDERECO:
            return self.handle_endereco(raw)
        if self.current_state == State.PAGAMENTO:
            return self.handle_pagamento(raw)
        if self.current_state == State.CARTAO:
            return self.handle_cartao(raw)

        # fallback
        self.current_state = State.SAUDACAO
        return "Desculpe, n√£o entendi. Reiniciando atendimento."

    def _reset_session(self):
        self.tipo = None  # "local" ou "entrega"
        self.pedido = []  # lista de dicts: nome, preco, categoria, quantidade
        self.item_em_selecao = None
        self.current_category = None
        self.endereco = None
        self.metodo_pagamento = None
        self.alteracao_tipo = None
        self.selecao_para_alterar = None

    def run(self):
        print("Bem-vindo √† Sanduicheira! (digite 'sair' para encerrar a qualquer momento)\n")
        print(self.respond(""))
        while True:
            try:
                user_input = input("\nVoc√™: ")
            except (KeyboardInterrupt, EOFError):
                print("\nBot: Encerrando... At√© logo!")
                sys.exit(0)

            if user_input is None:
                user_input = ""

            low = self.normalize(user_input)
            if low in ("sair", "encerrar", "fim", "exit"):
                print("Bot: Obrigado! Volte sempre!")
                break

            reply = self.respond(user_input)
            print("\nBot:", reply)

if __name__ == "__main__":
    SanduicheiraAssistant().run()

